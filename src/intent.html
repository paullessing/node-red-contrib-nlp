

<script type="text/html" data-template-name="intent">
  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name">
  </div>
  <div class="form-row node-input-rule-container-row">
    <ol id="utterances-container">

    </ol>
    <input type="hidden" id="node-input-utterances">
  </div>
</script>

<script type="text/html" data-help-name="intent">
  <p>A node that converts inputs into intents</p>
</script>

<script type="text/javascript">
  RED.nodes.registerType('intent',{
    category: 'nlp',
    color: '#ffd9f8',
    defaults: {
      name: {value:""},
      utterances: {value: []}
    },
    inputs:1,
    outputs:1,
    icon: "comment.png",
    label: function() {
      return this.name||"intent";
    },
    oneditprepare: function() {
      // $("#node-input-payload").typedInput({
      //   default: 'str',
      //   typeField: $("#node-input-payloadType"),
      //   types:['str']
      // });

      $("#utterances-container").css('min-height','150px').css('min-width','450px').editableList({
        addItem: function(container,i,opt) {
          const wrapper = $(
            `<div style="display: flex">
               <input
                 type="text"
                 placeholder="Utterance"
                 style="flex: 1 1 70%"
                 data-key="utterance"
               >
               <input
                 type="text"
                 placeholder="Intent"
                 style="flex: 1 1 30%; margin-left: 5px"
                 data-key="intent"
               >
             </div>`);
          wrapper.appendTo(container);

          if (opt.hasOwnProperty('utterance')) {
            const { utterance, intent } = opt.utterance;
            wrapper.find('[data-key=utterance]').val(utterance);
            wrapper.find('[data-key=intent]').val(intent);
          }
        },
        removeItem: function(opt) {
          // console.log('Remove', arguments);
        },
        // resizeItem: resizeRule,
        // sortItems: function(rules) {
        //   var currentOutputs = JSON.parse(outputCount.val()||"{}");
        //   var rules = $("#node-input-rule-container").editableList('items');
        //   rules.each(function(i) {
        //     $(this).find(".node-input-rule-index").html(i+1);
        //     var data = $(this).data('data');
        //     currentOutputs[data.hasOwnProperty('i')?data.i:data._i] = i;
        //   });
        //   outputCount.val(JSON.stringify(currentOutputs));
        // },
        sortable: true,
        removable: true
      });

      let utterances = this.utterances;
      if (typeof this.utterances === 'string') {
        try {
          utterances = JSON.parse(this.utterances);
        } catch (e) {}
      }

      const defaultValue = { utterance: '', intent: '' };
      if (!utterances || !utterances.length) {
        utterances = [defaultValue];
      }
      utterances.forEach((utterance) => {
        $("#utterances-container").editableList('addItem',{ utterance });
      });
    },
    oneditsave: function() {
      // console.log('Saving');
      const utteranceList = $("#utterances-container").editableList('items');
      const utterances = [];
      utteranceList.each(function (i) {
        const utterance = $(this).find('[data-key=utterance]').val();
        const intent = $(this).find('[data-key=intent]').val();
        utterances.push({
          utterance, intent
        });
      });
      // console.log('Utterances', utterances);
      $('#node-input-utterances').val(JSON.stringify(utterances));
    }
  });
</script>
